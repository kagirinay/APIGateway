# APIGateway
Дипломный проект

Итоговая аттестация по программе «Профессия "Backend-разработчик на Go"» (PJ)

Этап 1
Реализовать скелет сервиса API Gateway.
Как это сделать? В данный момент у вас нет исходников или заготовок данного проекта.
Создайте новый проект в IDE, назовите его APIGateway.
Нужно в рамках этого проекта поднять HTTP-сервер для адреса: http://localhost:8080/.

И добавить следующие обработчики:

метод вывода списка новостей,
метод фильтра новостей,
метод получения детальной новости,
метод добавления комментария.

Пока нам не нужно делать полную реализацию. Вам требуется:

добавить модели NewsFullDetailed, NewsShortDetailed, Comment,
в методах, которые отдают данные, в теле определить объект или массив (в зависимости от метода)
и возвращать эти данные в качестве ответа.

То есть вам нужно использовать то, что называется hard-code.
Методы будут возвращать всегда одно и то же, но пока это не важно.
Если вы работаете со специалистом, который разрабатывает фронтенд, ему будет достаточно заглушек,
чтоб начать интеграцию. Главное, чтобы вы утвердили формат и не меняли его в процессе,
так как разработчику фронтенда потребуется часто менять код, а это неправильно.

Этап 2
Реализовать сервис комментариев.
Так как он нам потребуется в дальнейшем, заглушками обойтись не получится.
Вы, конечно, можете начать с заглушек, но в конце недели ожидается полностью рабочий сервис.

Что должен уметь сервис:

Принять ID новости и текст комментария или ID родительского комментария
(на которые кто-то отвечает), и сохранить это в БД.
Метод для выгрузки всех комментарием по ID новости.
Пока представим, что комментариев не много и нам не нужно делать пагинацию.
Пункт со звездочкой для тех, кто любит писать код и делает это быстрее остальных.
Асинхронный внутренний процесс (например, горутина, запущенная из функции main),
который будет брать новые комментарии, проверять их на наличие недопустимых слов
или словосочетаний и ставить отметку: допускается к показу или заблокирован.
Под списком фраз имеются в виду ругательства, но так как мы не можем себе
позволить писать это в исходниках, предлагаем использовать в качестве недопустимых слов qwerty, йцукен, zxvbnm.

Этап 3
Реализация асинхронного запроса
Для организации асинхронных запросов достаточно каждый запрос запустить в своей горутине.
При этом, нам нужно будет дождаться выполнения всех запросов.

Первое, что нам потребуется, — это канал.
В него мы будем писать из наших горутин результат запроса и ошибку,
которая может возникнуть в ходе отправки запроса.
Если хотя бы одна горутина вернула ошибку, то весь запрос от клиента считается проваленным,
и следует вернуть из API Gateway ошибку. Канал нужно создать с буфером, равным количеству запросов.
Чтобы дождаться выполнения запросов, нужно создать WaitGroup из пакета sync со счётчиком,
равным количеству запросов, который будет передан в каждую горутину.
Когда горутина отправила ответ от своего сервиса или произошла ошибка,
она перед завершением уменьшает счётчик группы на единицу за счёт вызова метода Done.
Лучше всего этот вызов сделать отложенным в начале функции при помощи ключевого слова defer.
После запуска, на группе необходимо вызвать метод Wait,
на котором заблокируется выполнение основной функции до тех пор, пока горутины не завершат свою работу.
Далее следует описать цикл, который будет читать структуры с ответами и ошибками из канала.
Как уже сказано ранее, если хотя бы одна горутина вернула ошибку, весь запрос считается неудачным.
Если все запросы отработали без ошибок, следует подготовить итоговую структуру,
в которую из ответа от агрегатора будет записана детальная информация о новости,
а из ответа от сервиса комментариев будет записан массив комментариев к этой новости.

Этап 4
Запрос на создание комментария к новости
Так же, как с запросом на получение списка новостей,
передаём данные запроса в сервис комментариев, а ответ от него передаём клиенту,
сделавшему запрос.

Поскольку API gateway создаётся для клиентских приложений,
формат запросов, которые он принимает и ответов, которые он
отдает может отличаться от формата внутреннего сервиса, к которому посылает запрос API gateway.
В таком случае потребуется произвести конвертацию ответа сервиса комментариев в ответ приемлемый для клиента.

Этап 5
Знакомство с новыми требованиями к агрегатору
Добавить поиск по названию новостей

Наша задача добавить возможность передачи в запросе на получение новостей параметра,
в качестве значения которого будет строка, по которой будет производиться поиск в заголовке новости.
Добавить постраничную навигацию к запросу списка новостей

Требуется добавить параметр к запросу списка новостей, который будет отвечать за номер страницы,
показываемой пользователю. Также в существующую структуру ответа потребуется добавить структуру
с данными о постраничной навигации (пагинации).
Добавить сквозной идентификатор запроса

В каждый запрос, независимо от его назначения, требуется добавить параметр,
который будет передаваться извне. В нём будет содержаться уникальный идентификатор запроса.
Этот идентификатор нужно будет так же передавать в случае обращения к другим микросервисам
в рамках запроса от клиента.
Добавить журналирование запросов

Данные о каждом HTTP-запросе, независимо от его назначения, требуется журналировать.
Данные, которые необходимо сохранить:

время запроса,
IP-адрес, с которого был отправлен запрос,
HTTP-код ответа,
уникальный ID запроса.
Этап 6
Создание сервиса цензуры комментариев
Ранее созданную асинхронную горутину,
которая должна в фоне производить цензурирование комментариев в базе данных и выставлять им соответствующий флаг.
Если комментарий прошел проверку, его можно показывать, иначе — нельзя.
Вынести данную функциональность в отдельный микросервис.

Требования к сервису
поддержка сквозного идентификатора,
журналирование запросов.
Реализация:
Создание и разработка сервиса цензурирования

Для начала нужно будет также создать новый проект.
Этот сервис, как и все другие, будет содержать HTTP-сервер.
Здесь нам нужно реализовать обработчик одного запроса методом POST,
на который будут передавать текст комментария. Если комментарий прошел валидацию, возвращается 200 ответ.
Если не прошел — 400.
Для поддержки сквозного идентификатора и журналирования запросов необходимо воспользоваться middleware,
ранее разработанного.
Подключение API Gateway

Здесь нам потребуется отредактировать обработчик создания комментария.
Теперь перед тем как отправить запрос непосредственно на создание комментария в сервис комментариев,
его сначала нужно передать сервису цензурирования.
В случае 200 ответа от сервиса цензурирования мы можем создать комментарий.
В случае 400 ответа, следует вернуть ошибку клиенту.

Этап 7
Доработка сервиса комментариев
Поскольку мы вынесли функциональность для проверки комментария в отдельный сервис,
из сервиса комментариев функциональность цензурирования комментария следует удалить.
Также следует отредактировать схему базы таким образом, чтобы никаких флагов о том,
можно ли показывать комментарий или нет, не было.

Далее необходимо по примеру агрегатора добавить в сервис комментариев поддержку
сквозного идентификатора и журналирование запросов. Это можно легко сделать при помощи middleware,
которые были реализованы ранее для агрегатора новостей.

Этап 8
Доработка API Gateway
Ранее доработали API Gateway в соответствии с новыми бизнес-требованиями.
Теперь нам следует доработать обработчики запросов API Gateway таким образом,
чтобы он был полностью совместим с новыми параметрами агрегатора.

Сначала добавим поддержку поиска по названию новостей.

Аналогично тому, как это сделано в агрегаторе, следует добавить поддержку параметра s,
значение которого нужно будет передавать при запросе в агрегатор.
Далее добавим параметр, отвечающий за пагинацию.

Аналогично тому, как это сделано в агрегаторе, следует добавить поддержку параметра page,
значение которого нужно будет передавать при запросе в агрегатор.
Далее добавим поддержку сквозного идентификатора.

Аналогично тому, как это сделано в агрегаторе, следует добавить поддержку параметра request_id.
Помимо того, что данный параметр следует указывать при логировании запросов,
его также следует передавать во все запросы к нижележащим сервисам,
чтобы наш сквозной идентификатор был зафиксирован во всех сервисах в рамках одного запроса,
и путь этого запроса можно было отследить при необходимости в логах при помощи специального программного обеспечения.
Для поддержки сквозного идентификатора следует использовать middleware, созданный для агрегатора новостей
И, наконец, добавим журналирование запросов аналогично тому, как это было сделано в агрегаторе новостей.

Для включения журналирования запросов следует использовать middleware, созданный для агрегатора новостей
Этап 9
Тестирование всей системы
На данном этапе наша с вами разработка системы практически завершена.
Остаётся последний, завершающий этап — тестирование.

Проводить тестирование системы мы будем при помощи уже известной вам программы — Postman.

Этап 10
Запуск системы
Для начала, запустим все наши микросервисы. Убедимся в том, что HTTP-серверы запущены.

Очень полезно при запуске сервиса писать в stdout сообщение о том, что сервис запущен,
а дальше перечислить адреса программных интерфейсов, к которым можно подключаться, например:

    [*] HTTP server is started on localhost:8080
    [*] TCP server is started on localhost:8081
Также хорошей практикой будет написать подобные сообщения при завершении работы серверов,
чтобы отследить, что они успешно завершили свою работу. Например:

    [*] HTTP server has been stopped. Reason: got sigterm
    [*] TCP server has been stopped. Reason: got sigterm
Если появились сообщения о запуске сервера и не происходит его падение с ошибками,
значит, приложение после запуска готово к работе, можно переходить к следующему шагу.

Этап 11
Тестирование обработчиков
Поскольку внешний клиент, например, веб-приложение, будет работать с нашей системой только через API Gateway,
тестировать нашу систему мы будем также через него.

Задача нашего тестирования заключается в том,
чтобы послать запрос на каждый обработчик API Gateway и получить тот ответ, который мы ожидаем.

Данный метод тестирования является достаточно простым для быстрой проверки работоспособности системы в целом,
но он не позволяет проверить работу в разных условиях каждого отдельного микросервиса.

На данном этапе нам этого достаточно, поскольку наша система небольшая,
а различных сценариев тестирования не так много, чтобы писать автоматизированные тесты.

Этап 12
Получение новостей
Для начала протестируем получение новостей.
Чтобы проверить этот обработчик, убедитесь, что база данных агрегатора новостей не пустая.

Далее нам следует послать GET-запрос на обработчик. Сначала без параметров, чтобы проверить, что он работает.

Первое, что нужно проверить — это код ответа.
Он должен быть 2**. Если код ответа не 2**, следует искать причину поломки.
В этом нам должны помочь сообщения об ошибках.

Помимо 2** кода, мы должны получить тело ответа в формате JSON — массив с объектами новостей.

Как вы помните, если мы не указали номер страницы,
автоматически должна быть запрошена первая страница с фиксированным количеством элементов.
Таким образом, следует сверить количество объектов,
которые мы получили в ответе с фиксированным количеством элементов на страницу.

Далее нам следует внимательно проверить объект пагинации, который мы получили.
Проверить общее число страниц достаточно просто.
Можно выполнить запрос SELECT count(*) FROM... в базу агрегатора новостей
без параметров и разделить полученное значение на фиксированное значение элементов на страницу.
Учтите, что у нас работает в фоне горутина, которая сканирует источники новостей.
Если значение объекта пагинации и запроса отличаются, то лучше проверить сначала,
не появились ли новые новости в базе.

После того как мы сверили все данные и убедились, что всё работает,
проверим работу постраничной навигации. Укажем в запросе параметр page со значением 2.

Мы должны будем получить похожий ответ, только теперь в объекте пагинации будет указана 2 страница,
а также мы получим другие новости, но в таком же количестве. При условии, что мы находимся не на последней странице.

Далее попробуем запросить последнюю страницу. Ее номер мы должны взять, как раз, из объекта пагинации.

Последняя страница может содержать меньше элементов, чем указано в фиксированном количестве по понятным причинам.

Далее проверим фильтр новостей, который ищет по заголовку статьи. Передадим параметр s,
в котором укажем какое-нибудь ключевое слово, которое часто встречается в заголовках новостей.
В ответе мы должны увидеть все новости, заголовки которых содержат это слово.

Проверить правильность и количество результатов можно также при помощи запроса в базу агрегатора.
Запрос должен быть следующего вида:

    SELECT * FROM <news_table_name> WHERE <title_col_name> ILIKE '%<keyword>%';
Где:

<news_table_name> — название вашей таблицы с новостями (без угловатых скобок);
<title_col_name> — название колонки, где хранятся заголовки новостей (без угловатых скобок);
<keyword> — ключевое слово или фраза, по которой будет производиться поиск по шаблону при помощи оператора ILIKE.

Пример запроса:

    SELECT * FROM news WHERE title ILIKE '%python%';
Ваш запрос, возможно, будет отличаться названиями таблицы, колонки и, разумеется, ключевым словом для поиска.

Этап 13
Создание комментария к новости
К данному обработчику у нас будет 2 основных сценария тестирования:

Когда текст комментария прошел цензурирование.
Когда текст комментария не прошел цензурирование.

Чтобы проверить работу данного обработчика, давайте выберем из списка новостей любую,
которая вам нравится, и отправим методом POST запрос на создание комментария
(обработчик запроса создания комментария должен работать именно через метод POST согласно REST).

Сначала отправим текст, который не должен пройти цензуру.
В ответ мы должны получить 400 статус ответа с соответствующим пояснением.
Если был получен 2** статус ответа, цензурирование не сработало.
Проверьте, что API Gateway послал запрос на цензурирование и передал в него текст комментария.
Также можно проверить отдельно API сервиса комментариев, чтобы сначала исключить проблемы с ним,
а уже дальше возвращаться непосредственно к API Gateway.

Далее отправим текст, который должен пройти цензуру. В ответ мы должны получить 2** статус ответа.

Чтобы проверить, что комментарий действительно был создан,
давайте отправим SELECT запрос в базу данных сервиса комментариев.
Мы должны увидеть созданный для для новости комментарий. Проверьте, что текст совпадает,
а также идентификатор новости тот, для которого мы этот комментарий создавали.

Этап 14
Получение деталей новости и комментариев
Последнее, что нам осталось сделать — это проверить получение информации по одной новости.

Давайте отправим GET запрос на последний обработчик, указав идентификатор новости,
информацию о которой мы хотим получить. Лучше всего указать ту новость,
для которой только что созданы были комментарии.

В ответе мы должны получить информацию о данной новости + комментарии, которые были для неё созданы.

Если мы получили код, отличный от 2**, смотрим на сообщение об ошибке и начинаем разбираться.
Сначала, как обычно, нужно понять, в каком сервисе ошибка. Для этого можно посмотреть логи сервисов,
через которые идет запрос, и понять, где запрос оборвался. Здесь понять, какой лог относится к какому запросу,
нам поможет наш сквозной идентификатор.
Далее локализуем в конкретном сервисе место, где произошла ошибка и вносим необходимые правки.

Если информация о новости была получена, а комментарии — нет,
хотя мы знаем, что они точно есть, нужно проверить получение данных на стороне API Gateway.